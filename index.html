<html>
<head>
	<style>
		body {
			margin: 0px;
			padding: 0px;
		}
	</style>
	<script src="requestAnimFrame.js"></script>
	<script src="Keyboard.js"></script>
	<script src="socket.io.min.js"></script>
</head>
<body>
	<div id="canvas">
		<canvas id="myCanvas"></canvas>
	</div>
	<script>

		var socket = io.connect('http://localhost:4242');
		socket.id = socket.socket.sessionid;

		var canvas = document.getElementById('myCanvas');
		var context = canvas.getContext('2d');

		var keyboard = new KeyboardJS(false);
		var camera = new Camera(canvas.width/2, canvas.height/2);

		var map_width = 1200;
		var map_height = 1200;

		var view_field = 8;

		var players = {};

		var grid = {};
		var cellSize = 40;
		var margin = 5;

		var oldKeys = {};
		var keyD = 68;
		var keyA = 65;
		var keyW = 87;
		var keyS = 83;
		var keyI = 73;
		var keyJ = 74;
		var keyK = 75;
		var keyL = 76;

		function Camera(x,y,type){
			this.x = x-canvas.width/2;
			this.y = y-canvas.height/2;
		}

		function Cell(x,y,type){
			this.x = x;
			this.y = y;
			this.type = type || 'fog';
		}
		Cell.prototype.render = function (ctx) {
			if (this.type == 'fog'){
				ctx.fillStyle = 'grey';
				ctx.fillRect(this.x*cellSize-margin,this.y*cellSize-margin,cellSize,cellSize);
			}
			else if (this.type == "sight") {
				ctx.fillStyle = this.color || 'white';
				ctx.fillRect(this.x*cellSize-margin,this.y*cellSize-margin,cellSize,cellSize);
			}
			else if (this.type == "seen") {
				ctx.fillStyle = this.color || 'lightgrey';
				ctx.fillRect(this.x*cellSize-margin,this.y*cellSize-margin,cellSize,cellSize);
			}
			else {
				ctx.fillStyle = 'white';
				ctx.fillRect(this.x*cellSize-margin,this.y*cellSize-margin,cellSize,cellSize);
				ctx.fillStyle = this.color;
				ctx.fillRect(this.x*cellSize,this.y*cellSize,cellSize-margin*2,cellSize-margin*2);
			}
			//Pintem requadre
			ctx.strokeStyle = 'black';
			ctx.strokeRect(this.x*cellSize-margin,this.y*cellSize-margin,cellSize,cellSize);

			// pintem health bar
			if (this.type == 'player'){
				ctx.fillStyle = 'red';
				ctx.fillRect(this.x*cellSize-3,this.y*cellSize-8,cellSize-margin*2+6,5);
				ctx.fillStyle = 'green';
				ctx.fillRect(this.x*cellSize-3,this.y*cellSize-8,(cellSize-margin*2+6)*players[this.player].HP/100,5);
			}
		}
		Cell.prototype.logic = function(playerCell) {
			if (this.type == "fog" || this.type == "seen"){
				if (Math.abs(playerCell.x - this.x) + Math.abs(playerCell.y - this.y) <= view_field){
					this.type = "sight";
				}
			}
			else if (this.type == "sight"){
				if (Math.abs(playerCell.x - this.x) + Math.abs(playerCell.y - this.y) > view_field){
					this.type = "seen";
				}
			}
		}

		function Player(id){
			this.id = id;
		}
		Player.prototype.updateData = function (player){
			this.HP = player.HP;
			this.AD = player.AD;
		}

		socket.on('playerUpdate', function (player){
			if (players[player.id] === undefined){
				var newPlayer = new Player(player.id);
				players[player.id] = newPlayer;
			}
			players[player.id].updateData(player);
		});

		socket.on('deletePlayer', function (id) {
			delete players[id];
		});

		socket.on('gridUpdate', function (cell) {
			var playerCell = new Cell(0,0,'loading');
			for (position in grid){
				if (grid[position].player == socket.socket.sessionid){
					playerCell = grid[position];
				}
			}

			if (playerCell.type == 'loading' || Math.abs(playerCell.x - cell.x) + Math.abs(playerCell.y - cell.y) <= view_field){
				var newcell = new Cell(cell.x,cell.y);
				newcell.position = cell.position;
				newcell.type = cell.type;
				newcell.player = cell.player;
				newcell.color = cell.color;
				newcell.AD = cell.AD;
				newcell.HP = cell.HP;
				grid[cell.position] = newcell;
			}
		});

		socket.on('deleteCell', function (pos) {
			var playerCell = new Cell(0,0,'loading');
			for (position in grid){
				if (grid[position].player == socket.socket.sessionid){
					playerCell = grid[position];
				}
			}

			if (grid[pos] !== undefined){
				if (grid[pos].type !== 'wall'){
					//if (Math.abs(playerCell.x - grid[pos].x) + Math.abs(playerCell.y - grid[pos].y) <= view_field){
						var newcell = new Cell();
						newcell.x = grid[pos].x;
						newcell.y = grid[pos].y;
						newcell.type = 'seen';
						grid[pos] = newcell;

					//}
				}
			}
		});

		function printGrid (ctx) {

			ctx.strokeStyle = 'black';

			// Iterate for x.
			for (var i = 0; i <= map_width; i += cellSize) {
				ctx.beginPath();
				ctx.moveTo(i,0);
				ctx.lineTo(i,map_height);
				ctx.stroke();
			}

			// Iterate for y.
			for (var i = 0; i <= map_height; i += cellSize) {
				ctx.beginPath();
				ctx.moveTo(0,i);
				ctx.lineTo(map_width,i);
				ctx.stroke();
			}
		}

		function printFogOfWar (ctx,cell) {

			vision = Math.floor(cell.x*cellSize-view_field*cellSize);
			ctx.fillStyle = 'white';

			for (var i = 0; i < view_field+1; ++i) {
				ctx.fillRect(vision+i*cellSize-margin,(cell.y-i)*cellSize-margin,(view_field-i)*cellSize*2+cellSize,(2*i+1)*cellSize);
			}
		}

		function render() {

			var player = new Cell(0,0,'loading');

			//	Camera translate
			for (position in grid){
				if (grid[position].player == socket.socket.sessionid){
					player = grid[position];
					camera.x += (player.x*cellSize+cellSize/2 - canvas.width/2 - camera.x)/40;
					camera.y += (player.y*cellSize+cellSize/2 - canvas.height/2 - camera.y)/40;
				}
			}

			initialX = Math.floor(camera.x/cellSize);
			initialY = Math.floor(camera.y/cellSize);
			finalX = Math.floor(initialX + (canvas.width+cellSize)/cellSize);
			finalY = Math.floor(initialY + (canvas.height+cellSize)/cellSize);

			context.save();
			context.translate(-camera.x,-camera.y);
			context.translate(margin,margin);

			//printFogOfWar(context,player);	

			if (player.type == 'loading'){
				context.clearRect(0,0,canvas.width,canvas.height);
			}
			else {
				for (var i = initialX; i <= finalX; i++) {		
					for (var j = initialY; j <= finalY; j++){
						var coord = i+'x'+j;
						if (grid[coord] === undefined){
							console.log(coord);
							grid[coord] = new Cell(i,j,'fog');
						}
						grid[coord].logic(player);
						grid[coord].render(context);
					}
				}
			}
			context.restore()
		}

		function logic() {

			var player = new Cell();

			for (position in grid) {
				if (grid[position].player == socket.socket.sessionid) { 

					var player = grid[position];

					//	Movement keys (WASD)
					var dataMove = {pos: position, dir:{x:0,y:0}};
					if (!oldKeys[keyW] && keyboard.keys[keyW]) {
						dataMove['dir']['y'] = -1;
						socket.emit('move',dataMove);
					}
					if (!oldKeys[keyA] && keyboard.keys[keyA]) {
						dataMove['dir']['x'] = -1;
						socket.emit('move',dataMove);
					}
					if (!oldKeys[keyS] && keyboard.keys[keyS]) {
						dataMove['dir']['y'] = 1;
						socket.emit('move',dataMove);
					}
					if (!oldKeys[keyD] && keyboard.keys[keyD]) {
						dataMove['dir']['x'] = 1;
						socket.emit('move',dataMove);
					}

					//	Attack keys(IJKL)
					var dataAttack = {pos: position, dir:{x:0,y:0}};
					if (!oldKeys[keyI] && keyboard.keys[keyI]) {
						dataAttack['dir']['y'] = -1;
						socket.emit('attack',dataAttack);
					}
					if (!oldKeys[keyJ] && keyboard.keys[keyJ]) {
						dataAttack['dir']['x'] = -1;
						socket.emit('attack',dataAttack);
					}
					if (!oldKeys[keyK] && keyboard.keys[keyK]) {
						dataAttack['dir']['y'] = 1;
						socket.emit('attack',dataAttack);
					}
					if (!oldKeys[keyL] && keyboard.keys[keyL]) {
						dataAttack['dir']['x'] = 1;
						socket.emit('attack',dataAttack);
					}
					for (prop in keyboard.keys){
						oldKeys[prop] = keyboard.keys[prop];
					}					
				}
			}
		}

		function mainLoop() {
			requestAnimFrame(mainLoop);
			logic();
			render();
		}
		requestAnimFrame(mainLoop);

		window.onresize = function () {
			canvas.width = window.innerWidth-20;
			canvas.height = window.innerHeight-20;
			mainLoop();
		}
		window.onresize();
	</script>
</body>